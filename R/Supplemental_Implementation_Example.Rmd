---
  title: "Implementation Examples of multi-level meta-analytic models with robust variance estimators and using Bayesian approaches to deal with non-independent effect sizes"
  author: Shinichi Nakagawa, Alistair M. Senior, Wolfgang Viechtbauer and Daniel W. A. Noble
  date: "`r Sys.Date()`"
  bibliography: refs.bib
  csl: science.csl
  output: 
    bookdown::html_document2:
      code_folding: hide
      number_sections: no
      toc: yes
      toc_depth: 6
      toc_float: yes
    bookdown::word_document2:
      toc: no
      toc_depth: 6
      number_sections: true
      reference_docx: template.docx
  editor_options: 
    chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE, tidy = TRUE, fig.width = 10)
## numbers >= 10^5 will be denoted in scientific notation,      ## numbers >= 10^5 will be denoted in scientific notation,
  ## and rounded to 2 digits      ## and rounded to 2 digits
  options(digits = 2)
```

# Introduction
Here, we demonstrate using some simple simulated data how meta-analyst's can implement some simple methods to correct for inflated Type I error rates when using multilevel models with non-independent effect size data. For ease of presentation, we use simulated data throughout and demonstrate two of the simplest and most effective methods that are most robust to a wide array of contexts that a meta-analyst might be faced with in analyzing their data.

# R Packages Required

First, we'll load some of the packages that we'll need.

```{r packages_data}
  ##################################
  # Clean workspace
  ##################################
      rm(list=ls())

  ##################################
  # Loading packages & Functions
  ##################################
      install.packages("pacman")
      pacman::p_load(tidyverse, MASS, kableExtra, gridExtra,  MCMCglmm, brms,  metafor, robumeta, clubSandwich)
```

# Simulating non-independent effect size data

Here, we will simulate some meta-analytic data assuming a correlation between effect sizes within studies as r = 0.5.

```{r simulated data}
    # Simulate a dataset composed of 30 papers, each having between 5 effects from the same study.
  
    set.seed(86)

    # Parameters
       no.paper = 30
      n.effects = 5
          rho.e = 0.5

    # Create covariance matrix for correlations within studies. Assume SD = 1.
            cov.e <- matrix(data=rho.e, nrow=no.effects, ncol=no.effects)
      diag(cor.e) <- 1

    # Create full matrix for all effect sizes; blocked by study. In other words, effects from a study are independent, but correlated by r=0.5 within study. 
         cov.e_all <- as.matrix(Matrix::bdiag(replicate(no.paper, cov.e, simplify=FALSE)))

    # Add sampling variance
           vi  <- diag( ,no.paper*n.effects)

    # Now create "effect sizes". This is not complete as we need sampling error etc. Add study specific effect (tau2 = 1.2). 
        effects <- MASS::mvrnorm(n = 1, mu = rep(0, n.effects*no.paper) + rep(rnorm(no.paper, 0, sqrt(1.2)), each = n.effects), cov.e_all + vi)    

    # Create the data. We'll just assume that meta-analysts have already derived their effect size and sampling variance
      data <- data.frame(study_id = rep(1:30, each = n.effects),
                               yi = effects,
                               vi = diag(vi),
                               obs = c(1:(n.effects*no.paper)))
   
```

# Fit the Multi-level Meta-analytic Model
```{r fitmodel}
mod_multilevel = metafor::rma.mv(yi=yi, V=vi, mods=~1, random=list(~1|study_id,~1|obs), data=data, test="t")
summary(mod_multilevel)
```
# Correction using Robust Variance Estimator (Method 6)

```{r fitrobust}
  mod_RVE <- robust(mod_multilevel, cluster = data$study_id)

 mod_RVE coef_test(mod4, vcov="CR2", cluster = data$study_id)
  summary(mod_RVE)
```
# Correction by Applying Bayesian Multi-level Meta-analytic Model (Method 9)

```{r fitrobust}
prior <- list(R = list(V = 1, nu = 0.002), 
              G = list(G1 = list(V = 1 , nu = 1, alpha.mu=0, alpha.V=25^2)))

   bayes_multilevel <- MCMCglmm(yi ~ 1, mev = data$vi, random = ~ study_id, data = data, prior = prior, verbose = FALSE)
   summary(bayes_multilevel)
```

vcv <- impute_covariance_matrix(vi = data$vi, cluster = SATcoaching$study, r = 0.

